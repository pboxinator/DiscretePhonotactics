
function λH(ñ=nothing;n=nothing)
    λ = 1000000000.
    if ñ==nothing return 0. end
    return 1/(λ*dot(SndV.(n)-SndV.(ñ),SndV.(n)-SndV.(ñ))+1/λ)
    end
#sum(λH.([nothing,nothing,nothing])) # Broadcast over wordList ñ; then sum the results over the broadcast.
# Note: sum(λH.([ñ])) is equivalent to λH(ñ)

function stringMerge(string1,string2)
    string3 = ["O" for _ in 1:length(string1)+length(string2)]
    [string3[k]=string1[k] for k in 1:length(string1)]
    [string3[k]=string2[k-length(string1)] for k in length(string1)+1:length(string1)+length(string2)]
    return string3
    end
	
function replaceWordString(Word,k,j)
    tWord = copy(Word)
    tWord[k] = Snd[j] # Replace kth-position sound in Word with sound j
    return tWord
    end
function replaceWordString!(Word,k,j)
    Word[k] = Snd[j] # Replace kth-position sound in Word with sound j
    end

function coolWord_singleSite_fromLast(Word::Array{String,1},k::Integer; output=false)
## Modifies the kth-site-from-last sound to one which minimizes the energy, then returns this new word.
    tWord = copy(Word)
    # Get list of all variations (and their energies) of Word with a new kth-site-from-last sound:
    nWords = [replaceWordString(tWord,length(tWord)-k+1,s) for s in 1:length(Snd)]
    nWords_energy = H.(nWords)
    # Find the minimum energy word in this sector:
    Emin = minimum(nWords_energy)
    nWord = nWords[argmin(nWords_energy)]
    # output:
    if output==true
        println(Word)
        println(nWords)
        println(nWord)
        end#if
    return nWord
    end#function_coolWord_singleSite!

function coolWord_singleSite(Word::Array{String,1},k::Integer; output=false)
## Modifies the kth-site sound to one which minimizes the energy, then returns this new word.
    tWord = copy(Word)
    # Get list of all variations (and their energies) of Word with a new kth-site sound:
    nWords = [replaceWordString(tWord,k,s) for s in 1:length(Snd)]
    nWords_energy = H.(nWords)
    # Find the minimum energy word in this sector:
    Emin = minimum(nWords_energy)
    nWord = nWords[argmin(nWords_energy)]
    # output:
    if output==true
        println(Word)
        println(nWords)
        println(nWord)
        end#if
    return nWord
    end#function_coolWord_singleSite!
	
function H(n::Array{String,1};ñList=[nothing]) # Input word "n" is a list of strings; and "ñList" contains words which we don't want "n" to equal (i.e n=ñ prohibitively expensive).
# Reformats string list into unit vectors and passes to H(n::Array{Array}) -- see above.
    return H([SndV(s) for s in prepWordString(n)]) + sum(λH.(ñList,n=n))
    end
	
function growWord(bWord;output=false,ñList=[nothing])
## Grow bWord by 1 sound which minimizes the energy in the length(bWord)+1 sound sector.
    # Get a list of all new words (and their energies) generated by adding a single sound to the base word:
    nWords = [stringMerge(bWord,[Snd[s]]) for s in 1:length(Snd)]
    nWords_Energy = H.([stringMerge(bWord,[Snd[s]]) for s in 1:length(Snd)],ñList=ñList)
    # Get the minimal energy word (WARNING: There may be degeneracy. Need way to get excited states!):
    Emin = minimum(nWords_Energy)
    nWord = nWords[argmin(nWords_Energy)]
    if output==true
        println("input word:")
        println(bWord)
        println(H(bWord))
        println("new word:")
        println(nWord)
        println(Emin)
        end
    return nWord
    end#function
# Overload:
growWord(x,y) = growWord(x,ñList=y)
	
# Need to make this gW function explicit over Array{String,1}:
#	so that I can also define one over Array{String,2}, but discritize.(x) replacing discritize(x).
#	This will allow me to grow multiple words at once.
function gW(x,y) # julia> gW("jul",["jula"])
	return growWord(discritize(x),discritize.(y)); end 
							# broadcast over ñList
function gW(x) # julia> gW("jul")
	return growWord(discritize(x)); end

right(s) = gW(s); # defines right(s) function
function left(s)
# Returns word s minus last sound:
	sp = copy(s); pop!(sp);
	return sp; end#left

function upN(s,N)
# For input word "s", returns the Nth lowest energy trailing sound in the dim(s)-sound conditional sector.
# (i.e Moves up in energy by N for the final sound of word "s".)
	nlist=[]; s1=copy(s); push!(nlist,s1);
	for _ in 1:N
		push!(nlist,gW(left(s),nlist)); end#for
	return last(nlist); end#upN




